---
title: "Reference cell atlas for decidua and villi"
subtitle: 
author: "Arun Chavan"
output:
  html_notebook:
    toc: yes
    toc_float: yes
    number_sections: true
bibliography: ../refs.bib
---
Started: 2020-08-31  
Last edited: `r format(Sys.time())`

```{r message=FALSE, warning=FALSE}
### packages
library(tidyverse)
library(scater)
```

# Background
The goal here is to create a reference set of celltype-specific transcriptomes for cell types present at the human fetal-maternal interface. Ideally we want bulk-representations of transcriptomes for all cell types. We can compare (by calculating correlation coefficients, e.g.) these to the averaged trancriptomes for each cluster from our data. The cell type to which a cluster has the highest similarity, is likely the cell type represented by that cluster. We can subsequently manually verify each of these assignments.   

We can use data from previous single cell RNA-seq studies to do this. There are three studies that we can use. 

1. [@pavlicev_single-cell_2017]: This is scRNA-seq of the villi at term. Appended to the villi data are also bulk transcriptomes of endometrial stormal fibroblasts (ESF) and decidual stromal cells (DSC) from primary cultures. Since this is an old fluidigm-based study, the number of cells is smaller compared to 10x. 
2. [@vento-tormo_single-cell_2018]: This is scRNA-seq of fetal-maternal interface in the first trimester. 
3. [@suryawanshi_single-cell_2018]: This is also scRNA-seq of fetal-maternal interface in the first trimester. 

Of these studies, [@pavlicev_single-cell_2017] is the only dataset from term samples. Even though our data are from term samples, it would be worth it to compare them to the first-trimester data from [@vento-tormo_single-cell_2018] and [@suryawanshi_single-cell_2018]. There are many cell types at the fetal-maternal interface that don't change through pregnancy---they can be easily cross-mapped even with the first-trimester data. Even for cell types that do change, we could use this comparison to narrow down their identities.


# Get data in shape
The data from all three studies are in different formats, use different gene names etc. We need to first get them all in shape and make them comparable. 

## Vento-Tormo et al
The raw feature by barcode counts matrix from the 10x runs (`raw_data_10x.txt`) were downloaded from ArrayExpress accession [E-MTAB-6701](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-6701/files/). The associated metadata file `meta_10x.txt` contains cell metadata including cluster ids and cell type annotations. 

We want to (1) read these data, (2) sum counts for all cell with the same cell type annotation, and (3) normalize counts to counts per million (cpm). This gives us bulk-representation of the transcriptomes for all annotated cell types. 

### Data

```{r}
### read data
vento.meta <- read.table("../info/from-papers/vento-tormo_2018/10x_arrayexpress/meta_10x.txt", header = TRUE, sep = "\t")
vento.raw <- readSparseCounts("../info/from-papers/vento-tormo_2018/10x_arrayexpress/raw_data_10x.txt", sep = "\t", row.names = TRUE, col.names = TRUE)  # have to use readSparseCounts because the file is too big. 
```

The counts matrix is for 64734 cells. 
```{r}
dim(vento.raw)
head(vento.raw[, 1:2])   # first five few rows and columns
```

The metadata looks like this:
```{r}
head(vento.meta, 10)  # cell metadata
```

According to the metadata file, there are 38 clusters. 
```{r}
vento.meta$final_cluster %>% unique() %>% sort() # final clusters
```

These clusters are associated with the following 31 cell types annotations. 
```{r}
vento.meta$annotation %>% unique() %>% sort() %>% cat(sep = ", ") # annotations
```

### Convert into a `SingleCellExperiment` object
```{r}
### create SingleCellExperiment object ----------------------------------------
vento.sce <- SingleCellExperiment(assays = list(counts = vento.raw))

### add colData ---------------------------------------------------------------
colData(vento.sce)$location <- vento.meta$location[match(rownames(colData(vento.sce)), 
                                                         table = rownames(vento.meta)
                                                         )] # anatomical location
colData(vento.sce)$celltype <- vento.meta$annotation[match(rownames(colData(vento.sce)),
                                                           table = rownames(vento.meta)
                                                           )] # cell type annotations

### rowData -------------------------------------------------------------------
# extract ensembl id from rownames
rowData(vento.sce)$ID <- gsub(pattern  = "(.+)(_)(ENSG\\d+)", 
                              replacement = "\\3", 
                              rownames(rowData(vento.sce)))

# extract gene symbol from gene names
rowData(vento.sce)$Symbol <- gsub(pattern = "_ENSG\\d+", 
                                  replacement = "", 
                                  rownames(rowData(vento.sce)))
```

### Aggregate data by cell type annotation
```{r}
# sum counts across barcodes by cell type annotation
vento.sum <- aggregateAcrossCells(vento.sce, 
                                  ids = vento.sce$celltype, 
                                  average = FALSE, 
                                  use_exprs_values = "counts")

# summed library sizes
colSums(vento.sum@assays@data@listData$counts)
```

```{r}
# calculate cpm
assay(vento.sum, "cpm") <- calculateCPM(assay(vento.sum, "counts"))

# write cpm to data.frame
vento.cpm <- assay(vento.sum, "cpm") %>% as.data.frame()

# change column names to legal characters and add `vento` suffix
names(vento.cpm)[names(vento.cpm) == "dNK p"] <- "dNK.p"
names(vento.cpm)[names(vento.cpm) == "Endo (f)"] <- "Endo.f"
names(vento.cpm)[names(vento.cpm) == "Endo (m)"] <- "Endo.m"
names(vento.cpm)[names(vento.cpm) == "Endo L"] <- "Endo.L"
names(vento.cpm)[names(vento.cpm) == "NK CD16-"] <- "NK.CD16neg"
names(vento.cpm)[names(vento.cpm) == "NK CD16+"] <- "NK.CD16pos"

names(vento.cpm) <- paste0("vento_", names(vento.cpm))

# add gene names column
vento.cpm$gene_name <- gsub("_ENSG\\d+", "", rownames(vento.cpm))
vento.cpm <- vento.cpm %>% relocate(gene_name) # make it the first column

# remove rows that have duplicated gene names
dupgenes <- table(vento.cpm$gene_name) %>% as.data.frame() %>% filter(Freq > 1)
vento.cpm <- vento.cpm[!(vento.cpm$gene_name %in% dupgenes$Var1), ]
rownames(vento.cpm) <- NULL

# write
write.csv(vento.cpm, file = "../results/01_reference-atlas/vento-tormo_cpm-by-celltype.csv", row.names = FALSE)

# remove full dataset
rm(vento.raw)
rm(vento.sce)
```

## Suryawanshi et al
[@suryawanshi_single-cell_2018] have provided TP10K normalized, averaged by cell type, data in the supplementary materials. So we don't have to do that ourselves. The data for villous and decidual cell types are in two separate sheets in the excel file `aau4788_Data_file_S1.xlsx`. We just have to read the two sheets, combine them, and add `surya` prefix to all samples, so that we can differentiate them from `vento` and `pvali` samples when we analyse them all together. 

### Data
```{r}
### read data
surya.dec <- readxl::read_excel("../info/from-papers/suryawanshi_2018/supp-data/aau4788_Data_file_S1.xlsx", sheet = "Decidua_averages_TPM10K", col_names = TRUE, range = "A1:N16968", trim_ws = TRUE)
surya.vil <- readxl::read_excel("../info/from-papers/suryawanshi_2018/supp-data/aau4788_Data_file_S1.xlsx", sheet = "Villi_averages_TPM10K", col_names = TRUE, range = "A1:J17107", trim_ws = TRUE)

### prefixes
names(surya.dec)[names(surya.dec) != "Gene"] <- paste0("surya_dec.", 
                                                       names(surya.dec)[names(surya.dec) != "Gene"])
names(surya.vil)[names(surya.vil) != "Gene"] <- paste0("surya_vil.",
                                                       names(surya.vil)[names(surya.vil) != "Gene"])

### merge
surya.tp10k <- dplyr::inner_join(surya.dec, surya.vil, by = "Gene")
```

```{r}
### fix gene names
# change column name
names(surya.tp10k)[names(surya.tp10k) == "Gene"] <- "gene_name"

# duplicates
table(surya.tp10k$gene_name) %>% as.data.frame() %>% filter(Freq > 1)
```
No need to remove duplicated gene names since there are none.

```{r}
surya.tp10k %>% head()
```

There are 22 cell types:
```{r}
names(surya.tp10k)[-1] %>% cat(sep = ", ")
```

```{r}
write.csv(surya.tp10k, "../results/01_reference-atlas/surya_tp10k-by-celltype.csv", row.names = FALSE)
```

## Pavlicev et al
The raw data are available on NCBI GEO, but I have transcriptomes averaged by cell type since I was involved in this study. We will just use those. 

### Data
This file was written on a different operating system, so the end of line characters are strange. When you try to read it with `read.table` with `col.names = TRUE` you get `more columns than column names` error. But it works fine if you don't set `col.names = TRUE`. But then the auto-generated column names get added and the actual colnames become the first row. You have to fix that manually as below. 

```{r}
### read data
pavli.tpm <- read.table("../info/from-papers/pavlicev_2017/data/SC-ESC-SYN.txt", sep = "\t")

### column names
# fix the colnames = TRUE issue 
names(pavli.tpm) <- pavli.tpm[1, ]
pavli.tpm <- pavli.tpm[-1, ]
pavli.tpm[, 2:9] <- lapply(pavli.tpm[, 2:9], as.numeric)

# rename gene names column
names(pavli.tpm)[names(pavli.tpm) == "geneID"] <- "gene_name"

# prefixes
names(pavli.tpm)[names(pavli.tpm) != "gene_name"] <- paste0("pavli_", names(pavli.tpm)[names(pavli.tpm) != "gene_name"])
```

```{r}
### duplicated gene names
table(pavli.tpm$gene_name) %>% as.data.frame() %>% filter(Freq > 1)
```
There are no duplicated rows. 

There are 8 cell types here:
```{r}
names(pavli.tpm)[names(pavli.tpm) != "gene_name"]  %>% cat(sep = ", ")
```

```{r}
# write
write.csv(pavli.tpm, "../results/01_reference-atlas/pavli_tpm-by-celltype.csv", row.names = FALSE)
```

# Merge datasets
These three datasets are from different sources, were generated using different technologies, and were processed using different methods. There are certainly batch effects and it's not appropriate the expression values directly amongst them. But, we might be able to calculate correlations between celltypes in all three datasets as long as we use non-parametric correlation. For that we have `inner_join` these datasets to the intersection of genes shared in them. 

```{r}
# join
vsp <- vento.cpm %>% 
  inner_join(surya.tp10k, by = "gene_name") %>% 
  inner_join(pavli.tpm, by = "gene_name")

# write
write.csv(vsp, "../results/01_reference-atlas/vento-surya-pavli_joined.csv", row.names = FALSE)
```

# Compare datasets
We can measure spearman correlations between all pair of cell types from all three datasets. This would be useful for two reasons: (1) sanity check to make sure that corresponding cell types between datasets have the highest similarity, (2) if this works, it is likely that comparison of these datasets with our data would give us meaningful cell type annotations. 

```{r}
# plotting function. dat = melted correlation matrix
cor_matrix_plot <- function(dat){
  ggplot(data = dat, aes(Var2, Var1, fill=value)) +
    geom_tile(colour="white") +
    # geom_text(aes(Var2, Var1, label = round(value, 2)), 
    #           color = "black", size = 2.5) +
    scale_fill_gradient(low = 'white', high = 'red',
                        limits =c((min(dat$value) - min(dat$value)*0.1), 1),
                        name="Spearman\nCorrelation") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle=90, vjust=1, size=8, 
                                     hjust=1, color='black'),
          axis.text.y = element_text(size=8, color='black'),
          axis.title = element_blank(),
          panel.grid = element_blank(),
          aspect.ratio = 1:1)
} 
```

```{r}
# cor matrix: all genes
data.cols <- c(2:63)
cor.matrix <- cor(sqrt(vsp[, data.cols]), method = "spearman")
cor.matrix.melted <- reshape2::melt(cor.matrix, na.rm = T)
cor_matrix_plot(cor.matrix.melted)
# ggsave(last_plot(), 
#        filename = 'analysis/all-genes/correlations/cormatrix_sqrt-tpm.pdf',
#        device = cairo_pdf, width = 8, height = 7, units = 'in')
```


# Session Info
```{r}
sessionInfo()
```

# References


