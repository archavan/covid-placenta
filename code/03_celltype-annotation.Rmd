---
title: "Annotation of clusters in 10x data"
subtitle: 
author: "Arun Chavan"
output:
  html_notebook:
    toc: yes
    toc_float: yes
    number_sections: true
bibliography: ../refs.bib
---
Started: 2020-09-02  
Last edited: `r format(Sys.time())`

```{r message=FALSE, warning=FALSE}
### packages
library(tidyverse)
library(Seurat)
library(kableExtra)
library(patchwork)
library(ggthemes)
```

We can take a first pass at annotating the clusters from our 10x data by comparing them to the reference dataset that we put together. This was done by compiling celltype-averaged expression values from the following single cell RNA-seq studies: [@pavlicev_single-cell_2017; @vento-tormo_single-cell_2018; @suryawanshi_single-cell_2018]. 

# COVID data and reference data
The single cell data were already clustered by Eric. The cluster-averaged gene expressions values are saved as `.csv` in a the folder sent to me by Alice.

```{r}
# read 10x data
plac <- read.csv("../info/from-alice/Previous Analysis/Genes by Cluster/placenta_Cluster_genes.csv", stringsAsFactors = FALSE)

# read reference datasets
ref <- read.csv("../results/01_reference-atlas/vento-surya-pavli_joined.csv", stringsAsFactors = FALSE)
```

## Samples
This is the sample information sent by Alice. Not sure about the INP id for `AL09` and `AL10`. The library for `INP188` villi (associated with `AL07`) was problematic, so is not used.  

```{r}
sample.info <- read.delim("../info/from-alice/sample_info.tsv", stringsAsFactors = FALSE)
sample.info %>% kable(caption = "Sample information") %>% kable_styling(full_width = FALSE)
```

## Get data in shape
In the COVID data, there are 35 clusters, labelled as `X0`, `X1`, and so on. The Gene names column is labeled `X`, which we will renames. We will also rename the clusters to have the prefix `clust_`. We will also join the data with the reference data so they are both in the same dataframe. 

```{r}
# rename columns
names(plac)[names(plac) == "X"] <- "gene_name"
names(plac)[names(plac) != "gene_name"] <- gsub("X", "clust_", names(plac)[names(plac) != "gene_name"])
names(plac) <- gsub("(clust_)(\\d)$", "\\10\\2", names(plac)) # left pad single digit cluster ids

# subset to exclude genes absent in the reference dataset
plac <- dplyr::inner_join(plac, ref, by = "gene_name")

head(plac)
```
## Correlations within the data
Before moving to annotating clusters by comparison with the reference dataset, first we will look at the correlation structure within the dataset.

```{r fig.asp=0.7}
# build correlation matrix from expression data
cor.matrix <- cor(plac %>% select(starts_with("clust")), method = 'spearman')

# reorder correlation matrix based on clustering
dd <- as.dist((1 - cor.matrix)) 
hc <- hclust(dd, method = 'complete')
cormat <- cor.matrix[hc$order, hc$order]

# melt correlation matrix
dat <- reshape2::melt(cormat, na.rm = T)

## plot
p <- ggplot(data = dat, aes(Var1, Var2, fill = value)) +
  geom_tile(colour = "white") +
  scale_fill_gradient(low = 'white', high = 'red',
                      name = "Spearman\nCorrelation") +
  coord_fixed(ratio = 1) +
  labs(title = "Correlations among clusters") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, size = 8, 
                                   hjust=1, vjust = 0.5),
        axis.text.y = element_text(size=8),
        axis.ticks.length = unit(0.15, units = c('lines')),
        legend.title = element_text(size = 10),
        axis.title = element_blank(),
        panel.grid = element_blank(),
        panel.border = element_blank(),
        legend.key.size = unit(0.8, units = c('lines')))

ggsave(p, filename = "../results/02_annotation/plots/corrplot_clusters.pdf", 
       device = "pdf", width = 7, height = 6, units = "in")

print(p)
```

There are three big cluster blocks, with substructure within them. The cluster blocks also correspond well with the UMAP plot that was sent by Alice. 

# Annotation by correlation
Let's now actually measure correlations between all clusters with the reference datasets. We will treat our data as query dataset and for each cluster assign top 3 cell types in each reference dataset.

```{r}
refdata <- c("vento", "surya", "pavli")

# build correlation matrix from expression data
cor.matrix <- cor(plac[, names(plac)[names(plac) != "gene_name"]], 
                  method = 'spearman')

# reorder correlation matrix based on clustering
dd <- as.dist((1 - cor.matrix))
hc <- hclust(dd, method = 'complete')
cormat <- cor.matrix[hc$order, hc$order]

# melt correlation matrix
dat <- reshape2::melt(cormat, na.rm = T)
dat$Var1_source <- sapply(strsplit(as.character(dat$Var1), split = "_"), "[[", 1)
dat$Var2_source <- sapply(strsplit(as.character(dat$Var2), split = "_"), "[[", 1)

# subset
dat <- dat[which(dat$Var1_source %in% refdata & 
                   dat$Var2_source == "clust"), ]

# top 3 matches with highest correlation coefficients
topmatch <- data.frame( # empty df to fill top matches from the loop below
  cluster = unique(as.character(dat$Var2)) %>% sort(),
  vento.top1 = NA,
  surya.top1 = NA,
  pavli.top1 = NA,
  vento.top2 = NA,
  surya.top2 = NA,
  pavli.top2 = NA,
  vento.top3 = NA,
  surya.top3 = NA,
  pavli.top3 = NA
)

dat$top3 <- NA

for(i in unique(dat$Var2)){
  for(j in refdata){
    # identify top3 match indices
    ind <- which(dat$Var2 == i & dat$Var1_source == j)
    val <- dat$value[ind]
    top3ind <- ind[order(val, decreasing = TRUE)[1:3]]
    
    # assign match ranking to correlation data for plotting
    dat$top3[top3ind[1]] <- "1"
    dat$top3[top3ind[2]] <- "2"
    dat$top3[top3ind[3]] <- "3"
    
    # assign top matches to topmatches dataframe
    topmatch[topmatch$cluster == i, paste0(j, ".top1")] <- gsub(paste0(j, "_"), "", as.character(dat$Var1[top3ind[1]]))
    topmatch[topmatch$cluster == i, paste0(j, ".top2")] <- gsub(paste0(j, "_"), "", as.character(dat$Var1[top3ind[2]]))
    topmatch[topmatch$cluster == i, paste0(j, ".top3")] <- gsub(paste0(j, "_"), "", as.character(dat$Var1[top3ind[3]]))
  }
}

```

## Plots

```{r}
# plotting function
clustAnnoPlot <- function(dat, query, reference){
  
  dat <- dat[which(dat$Var2_source == query & dat$Var1_source == reference), ]
  
  p <- ggplot(data = dat, 
              aes(Var1, Var2, fill = value)) +
    geom_tile(colour = "white") +
    scale_fill_gradient(low = 'white', high = 'red',
                        name = "Spearman\nCorrelation") +
    geom_point(aes(Var1, Var2, alpha = top3),
               size = 1.5, shape = 19, stroke  = 0) +
    scale_alpha_manual(values = c(1, 0.5, 0.25), 
                       breaks = c(1, 2, 3),
                       name = "top3", na.value = 0) +
    coord_fixed(ratio = 1) +
    xlab("reference") +
    ylab("query") +
    labs(caption = "For each celltype in query, black points represent top 3 celltypes from reference with highest correlation.",
         title = paste0(query, " vs. ", reference)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, size = 8, 
                                     hjust=1, vjust = 0.5),
          axis.text.y = element_text(size=8),
          axis.ticks.length = unit(0.15, units = c('lines')),
          legend.title = element_text(size = 10),
          axis.title = element_text(size = 8),
          plot.caption = element_text(size = 7),
          panel.grid = element_blank(),
          panel.border = element_blank(),
          legend.key.size = unit(0.8, units = c('lines')))
  
  return(p)
}

```

```{r fig.asp=0.9}
## Annotation plots
anno.vento <- clustAnnoPlot(dat = dat, query = "clust", reference = "vento")
cowplot::ggsave2(anno.vento, device = "pdf", width = 7.5, height = 6.5, units = "in",
                 filename = "../results/02_annotation/plots/annotation-by-correlation_ref-vento.pdf")
print(anno.vento)
```
```{r fig.asp=0.9, fig.width=7}
## Annotation plots
anno.surya <- clustAnnoPlot(dat = dat, query = "clust", reference = "surya")
cowplot::ggsave2(anno.surya, device = "pdf", width = 7.5, height = 6.5, units = "in",
                 filename = "../results/02_annotation/plots/annotation-by-correlation_ref-surya.pdf")
print(anno.surya)
```

```{r fig.asp=0.9}
## Annotation plots
anno.pavli <- clustAnnoPlot(dat = dat, query = "clust", reference = "pavli")
cowplot::ggsave2(anno.pavli, device = "pdf", width = 7, height = 6, units = "in",
                 filename = "../results/02_annotation/plots/annotation-by-correlation_ref-pavli.pdf")
print(anno.pavli)
```

## Top matches
```{r}
topmatch %>% knitr::kable(caption = "Top 3 matches against all reference datasets.")

```

## Labels for clusters
We need to create consistent labels for all cell types that we identify. Below is a `list` I created in which the top level objects are labels we will give to the cell types, within which contained are lists of corresponding labels from `vento` and `surya`. These are tentative labels. After the first pass, when we go through the clusters with a fine-toothed comb, we can modify them further. For example, if we have multiple clusters labeled as `dec.Mac` (decidual macrophages), and if those clusters are distinct, we can then break up this label into `dec.Mac1` and `dec.Mac2`. 

```{r}
labs <- list("dec.DSC"    = list("vento.lab" = c("dS1", "dS2", "dS3"),
                                 "surya.lab" = c("dec.DSC", "dec.FB1", "dec.FB2")),
             "dec.DC"     = list("vento.lab" = c("DC1", "DC2"),
                                 "surya.lab" = c("dec.DC1", "dec.DC2")),
             "dec.Mac"    = list("vento.lab" = c("dM1", "dM2", "dM3"),
                                 "surya.lab" = c("dec.MAC")),
             "dec.NK"     = list("vento.lab" = c("dNK.p", "dNK1", "dNK2", "dNK3", "NK.CD16neg", "NK.CD16pos"),
                                 "surya.lab" = c("dec.NK1", "dec.NK2")),
             "dec.SMC"    = list("vento.lab" = c("dP1", "dP2"),
                                 "surya.lab" = c("dec.SMC")),
             "dec.Endo"   = list("vento.lab" = c("Endo.m"),
                                 "surya.lab" = c("dec.VEC")),
             "dec.Epi"    = list("vento.lab" = c("Epi1", "Epi2"),
                                 "surya.lab" = c("dec.EEC")),
             "dec.Tcell"  = list("vento.lab" = c("Tcells"),
                                 "surya.lab" = c("dec.TC")),
             "vil.Endo"   = list("vento.lab" = c("Endo.f"),
                                 "surya.lab" = c("vil.VEC")),
             "vil.EVT"    = list("vento.lab" = c("EVT"),
                                 "surya.lab" = c("vil.EVT")),
             "vil.FB"     = list("vento.lab" = c("fFB1", "fFB2"),
                                 "surya.lab" = c("vil.FB1", "vil.FB2", "vil.FB3")),
             "vil.Hofb"   = list("vento.lab" = c("HB"),
                                 "surya.lab" = c("vil.HC")),
             "vil.SCT"    = list("vento.lab" = c("SCT"),
                                 "surya.lab" = c("vil.SCT")),
             "vil.VCT"    = list("vento.lab" = c("VCT"),
                                 "surya.lab" = c("vil.VCT")),
             "unk.Gran"   = list("vento.lab" = c("Granulocytes"),
                                 "surya.lab" = c()),
             "unk.ILC"    = list("vento.lab" = c("ILC3"),
                                 "surya.lab" = c()),
             "unk.Mono"   = list("vento.lab" = c("MO"),
                                 "surya.lab" = c()),
             "unk.Plasma" = list("vento.lab" = c("Plasma"),
                                 "surya.lab" = c()),
             "unk.EB"     = list("vento.lab" = c(),
                                 "surya.lab" = c("vil.EB")),
             "unk.Endo.L" = list("vento.lab" = c("Endo.L"),
                                 "surya.lab" = c("dec.LEC"))
)

```

## Matches consistent between reference datasets
The following clusters have consistent top1 match between `vento` and `surya` references, i.e. they correspond to the same cell type category. The `pavli` reference is too unresolved to be used diagnostically, so we will ignore it for now. For some cell types it is confirmatory, though, e.g. cluster_00 corresponds to DSC in all three references. 

```{r}
# find out which clusters are consistent.
# If vento.top1 and surya.top1 are found in the same item in the labs list, the mapping is consistent.
consistent <- c(NA)
for(i in 1:nrow(topmatch)){
  consistent[i] <- grep(topmatch$vento.top1[i], labs) == grep(topmatch$surya.top1[i], labs)
}

# subset to include consistent set
topmatch.cons <- topmatch %>% 
  filter(consistent) %>% 
  select(cluster, vento.top1, surya.top1)

# add our tentative labels to the clusters
for(i in 1:nrow(topmatch.cons)){
  topmatch.cons$label[i] <- names(labs)[grep(topmatch.cons$vento.top1[i], labs)]
}

# print
topmatch.cons[order(topmatch.cons$label), ] %>% knitr::kable()
```

## Ambiguous clusters
The top1 matches for some clusters with `vento` and `surya` are not the same. The are the clusters that will require a more detailed look to determine their identify. 

```{r}
# subset for ambiguous clusters
topmatch.ambig <- topmatch %>% 
  filter(!consistent) %>% 
  select(cluster, vento.top1, surya.top1)

# add our labels.
for(i in 1:nrow(topmatch.ambig)){
  topmatch.ambig$label[i] <- paste0(
    names(labs)[grep(topmatch.ambig$vento.top1[i], labs)],
    " or ",
    names(labs)[grep(topmatch.ambig$surya.top1[i], labs)]
    )
}

# print
topmatch.ambig[order(topmatch.ambig$label), ] %>% knitr::kable()
```

# Annotation refinement
The annotations we have so far are only a starting point. Now we can look at each annotation more carefully to make sure that everything makes sense.

## Sample contribution to clusters
One of the ways in which we can refine the clusters further is by knowing which tissue that sample arises from. For example, if a cluster has macrophage gene signature and if most cells in that cluster come from villi samples, we can further narrow down the identity of the cluster to Hofbauer cells. We can do this by simply counting for each cluster how many cells come from decidua vs villi and by calculating the percentage. 

For this we need to read the `Seurat`-processed (by Eric) data sent by Alice.  

```{r}
plac <- readRDS("../info/from-alice/placenta.rds")

head(plac@meta.data)
```
The `orig.ident` column in the metadata represents the sample IDs from the sample info table above. We just have rename them to left-pad the numbers for consistency.  

```{r}
# left pad orig.idents
plac@meta.data$orig.ident <- gsub("(AL)(\\d)$", "\\10\\2", plac@meta.data$orig.ident)

# add additional metadata (covid status, tissue)
plac@meta.data$covid <- sample.info$covid[match(x = plac@meta.data$orig.ident, 
                                                table = sample.info$sample_id)]
plac@meta.data$tissue <- sample.info$tissue[match(x = plac@meta.data$orig.ident,
                                                  table = sample.info$sample_id)]

# rename clusters for consistency
plac$seurat_clusters <- paste0("clust_", plac$seurat_clusters)
plac$seurat_clusters <- gsub("(clust_)(\\d$)", "\\10\\2", as.character(plac$seurat_clusters)) # left pad
plac$seurat_clusters <- factor(plac$seurat_clusters, levels = paste0("clust_", c("00", "01", "02", "03", "04", "05", "06", "07", "08", "09", 10:34)))
```

```{r fig.asp=1.2, fig.width=6.5}
# count cells in each cluster by tissue of origin
bytissue <- table(plac$tissue, plac$seurat_clusters) %>% 
  as.data.frame() %>% 
  rename(tissue = Var1, cluster = Var2, frequency = Freq)

# calculate fraction
for(i in 1:nrow(bytissue)){
  bytissue$fraction[i] <- bytissue$frequency[i]/
    sum(bytissue$frequency[bytissue$cluster == bytissue$cluster[i]])
}

# plot
p.cells <- ggplot(data = bytissue, aes(x = frequency, y = cluster)) +
  geom_bar(aes(fill = tissue), stat = "identity", position = "stack") +
  ggtitle("Number of cells")

p.frac <- ggplot(data = bytissue, aes(x = fraction, y = cluster)) +
  geom_bar(aes(fill = tissue), stat = "identity", position = "stack") +
  ggtitle("Fraction of cells")

p.cells + p.frac + plot_layout(guides = "collect", nrow = 2) +
  plot_annotation(caption = "Sample contribution to clusters") &
  coord_flip() &
  scale_fill_tableau(palette = "Classic 10 Medium") &
  theme_minimal() +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_line(size = 0.25),
        plot.title = element_text(size = 10),
        axis.text.x = element_text(angle = 90, vjust = 0.5))
  

```
Following clusters have more than 75% cells coming from the same tissue of origin. 

```{r}
bytissue[, c("cluster", "tissue", "fraction")] %>% 
  pivot_wider(names_from = "tissue", values_from = "fraction") %>% 
  filter(decidua > 0.75 | villi > 0.75) %>% 
  kable(digits = 2, row.names = FALSE, 
        caption = "Clusters with more than 75% cells from one tissue") %>%
  kable_styling(full_width = FALSE)
```

Following clusters have ambiguous origin, i.e. they contain cells from decidua and villi samples. 

```{r}
bytissue[, c("cluster", "tissue", "fraction")] %>% 
  pivot_wider(names_from = "tissue", values_from = "fraction") %>% 
  filter(decidua < 0.75 & villi < 0.75) %>% 
  kable(digits = 2, row.names = FALSE, 
        caption = "Clusters with cells from both tissues") %>%
  kable_styling(full_width = FALSE)
```


# Session Info
```{r}
sessionInfo()
```

# References

